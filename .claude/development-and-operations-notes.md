Relayooor - Development & Operations HandbookThis document provides a comprehensive technical overview of the Relayooor platform for developers and system operators.1. System ArchitectureRelayooor is a multi-component system designed for robustness and scalability. The primary services work together to provide monitoring, API, and web-based clearing functionalities.Component Overview┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   Vue.js Web    │────▶│   API Backend    │────▶│   Chainpulse    │
│   Application   │     │   (Go/Gin)       │     │   (Monitoring)  │
└─────────────────┘     └──────────────────┘     └─────────────────┘
         │                       │                         │
         │                       ▼                         │
         │              ┌──────────────────┐              │
         └─────────────▶│ Relayer Service  │◀─────────────┘
                        │  (Hermes/Go)     │
                        └──────────────────┘
Vue.js Web Application: The user-facing frontend built with Vue 3, TypeScript, and Pinia for state management. It provides the packet clearing wizard and wallet integration.API Backend (Go): A backend built with the Gin framework that handles the core business logic, including secure token generation, on-chain payment verification, and orchestrating the clearing process with the Hermes relayer.Chainpulse: A modified fork of the Rust-based IBC monitoring tool that gathers real-time metrics, detects stuck packets, and collects user-specific data.Relayer Service (Hermes): The standard IBC relayer that executes the packet clearing commands issued by the API backend.Supporting Infrastructure: Includes PostgreSQL for data persistence, Redis for caching, Prometheus for metrics collection, and Grafana for visualization.Authentication & Authorization FlowA user connects their wallet to view stuck packets.The API generates a cryptographically signed, single-use clearing token with a 5-minute expiry.The user makes an on-chain payment with the unique token in the transaction's memo field.The API backend verifies the payment on-chain and, upon success, triggers the packet clearing operation via the Hermes REST API.A WebSocket connection provides real-time status updates to the user's frontend.2. Technology StackFrontend: Vue 3, TypeScript, Vite, TailwindCSS, Pinia, Vue Query, WebSocketBackend: Go, Gin, HMAC token signing, WebSocket, Redis, PostgreSQLMonitoring: Rust-based Chainpulse (modified), Prometheus, GrafanaInfrastructure: Docker Compose, Nginx, Hermes REST API3. Full Stack DeploymentThe entire application is containerized and can be deployed using the provided Docker Compose file.PrerequisitesDocker Engine 20.10+ & Docker Compose 2.0+At least 8GB RAM and 10GB free disk spaceDeployment StepsClone the repository:git clone https://github.com/cordtus/relayooor.git
cd relayooor
Configure Environment: Copy .env.example to .env and populate it with the required service wallet address, a strong CLEARING_SECRET_KEY, database URLs, and RPC endpoints.Build and Run:# For a quick start
./start-full-stack.sh

# For manual control
docker-compose -f docker-compose.full.yml build
docker-compose -f docker-compose.full.yml up -d
Service Endpoints (Default Local)ServiceURLCredentialsWeb Applicationhttp://localhost-API Backendhttp://localhost:8080-Chainpulse APIhttp://localhost:3000-Chainpulse Metricshttp://localhost:3001/metrics-Prometheushttp://localhost:9090-Grafanahttp://localhost:3003admin / adminPostgreSQLlocalhost:5432postgres / postgres4. Local DevelopmentKey CommandsStart Frontend Dev Server: cd webapp && yarn devStart Backend API Server: cd relayer-middleware/api && go run cmd/server/main.goRun Backend Tests: cd relayer-middleware/api && go test ./...Run Frontend Linting: cd webapp && yarn lint5. Testing StrategyThe project employs a multi-layered testing strategy to ensure quality and reliability.Unit Tests: Go tests for backend service and logic functions; Jest/Vitest for frontend components and utility functions.Integration Tests: Test the interactions between the API and the database, the frontend and the API, and the integration with Chainpulse.End-to-End (E2E) Tests: Cover the complete user workflow, from connecting a wallet to receiving confirmation of a cleared packet. Cypress is recommended for these tests.Security & Performance Tests:Security: Focus on signature validation, token expiration, input sanitization (SQLi, XSS), and CORS policies.Performance: Load testing for concurrent users and stress testing of component failures (e.g., database or Chainpulse unavailability).
